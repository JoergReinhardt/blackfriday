// TYPE SYSTEM
//
// after lots of experimenting, I decided the best way is to keep the interface
// as simple as possible. One Method interfaces for the win but you might want
// to add one just to get shure. The main reason to reimplement a typesystem on
// top of gos existing type system, is due to the fact, that the reflection
// capabilitys are far to complex in features. far to complicated to use and
// don't perform that well either.
//
// That makes a type marker that performs well in comparisions, the essence of
// a type. The Value needs to be returnable in a generalized form, which is
// perfomed by the Value() mehode. Every value can additionaly be returned as
// its contained native type, but those methods differ by signature and can't
// be defined without the use of an empty interface. Everything else is up for
// grabs,
package agiledoc

import (
	"math/big"
)

// VALUE INTERFACE
//
// the base types are kept as simple as possible.
//
// NIL
//
// while returning an error and/or boolean when values don't exist, or turn out
// not to be converteable is one way of doing it, I think having a nil type to
// return instead, makes things much easyer and there are lots of additional
// reasons to have one anyway.
//
// FLAG
//
// since the type field is the essential difference to ordinary values, I
// decided to have bitflags as a type, to make the type acsess-, compare- and
// usable.
//
// INTEGER, RATIONAL & FLOAT
//
// parsing values embedded in text and perform calculations on them is the main
// goal of agiledocument, which makesnumbers are the essence of the agile
// document. they are implemented by math librarys big.int / big.float types,
// since those allready implement all nescessary type conversions, parsing from
// string included and they are highly optimized to perform well. flag type is
// another big.Int, since it also implements bitwise boolean operations.
//
// BYTES
//
// the source will be provided by blackfriday in form of a byte slice
//
type Value interface {
	Type() ValueType
	Value() Value
	ToType(ValueType) Value
}
type Values interface {
	Value
	Container
}
type KeyValue interface {
	Ident() string
	Value // Type() ValueType, Value() Value
}

// strings make the input handable as text.
//go:generate -command stringer -type ValueType
const (
	NIL  ValueType = 0
	BOOL ValueType = 1 << iota
	INTEGER
	FLOAT
	RATIONAL
	FLAG
	BYTE
	BYTES
	STRING
	VECTOR
)

type ValueType uint

// TYPES
//
type ( // are kept as close to the native types they are derived from, as possible
	emptyVal struct{} // the empty struct is taken as emptyVal
	flagVal  big.Int
	intVal   big.Int
	ratVal   big.Rat
	boolVal  bool
	byteVal  byte
	bytesVal []byte
	strVal   string
	vecVal   struct{ Container }
)

// funtion types that implement the interface
type (
	// for each interface method there is a function defined, representing it. By sharing it's type
	// signature and using a Value instance as its first parameter and only return type.
	//
	ValueFnT func(Value) Value // TYPE CONVERTING & RETURN METHOD
	TypeFnT  func(Value) ValueType
	IdentFnT func(KeyValue) string
	///
	/// FUNCTIONAL TYPE REPRESENTATION
	//
	// to convert from each allowed type to every type a value can be
	// converted to, without a lot of repeating, function types to
	// represent the native types are needed.
	//
	// the type system makes A function type that gets an interface type as
	// first parameter in it´s definition, acts like a method that works on
	// all instances that implement its receiving Interface parameter.
	BoolFnT     func(Value) bool
	BigIntFnT   func(Value) big.Int
	BigFloatFnT func(Value) big.Float
	BigRatFnT   func(Value) big.Rat
	ByteFnT     func(Value) byte
	BytesFnT    func(Value) []byte
	StringFnT   func(Value) string
	IntegerFnT  func(Value) int64
	FloatFnT    func(Value) float64
	ValuesFnT   func(Value) []Value
)

func (v *vecVal) Values() []Value {
	l := v.Container.Values()
	for _, val := range l {
		l = append(l, val.(Value))
	}
	return l
}
func (v vecVal) Slice() []interface{} {
	return v.Container.Slice()
}

// INTERFACE METHODS
//
// methods that share a name, need to be implemented once per receiving type
func (flagVal) Type() ValueType  { return FLAG }
func (intVal) Type() ValueType   { return INTEGER }
func (ratVal) Type() ValueType   { return RATIONAL }
func (boolVal) Type() ValueType  { return BOOL }
func (byteVal) Type() ValueType  { return BYTE }
func (bytesVal) Type() ValueType { return BYTES }
func (strVal) Type() ValueType   { return STRING }
func (vecVal) Type() ValueType   { return VECTOR }

func (v flagVal) Value() Value  { return v }
func (v intVal) Value() Value   { return v }
func (v ratVal) Value() Value   { return v }
func (v boolVal) Value() Value  { return v }
func (v byteVal) Value() Value  { return v }
func (v bytesVal) Value() Value { return v }
func (v strVal) Value() Value   { return v }
func (v vecVal) Value() Value   { return v }

// EMPTY TYPE
// the implementation of the empty type, will be instanciateable from thin air,
// used as base value type, that can convert a native value into the
// appropriate Value instance. It´s also used as a return type, whenever a type
// conversion can not be performed, or a variable lookup fails.
func (emptyVal) Type() ValueType         { return NIL }
func (emptyVal) Empty() emptyVal         { return emptyVal(struct{}{}) }
func (e emptyVal) Value() Value          { return emptyVal(struct{}{}) }
func (emptyVal) Set(v interface{}) Value { return newValueFromNativeType(v) }
func (v emptyVal) ToType(t ValueType) Value {
	return emptyVal{}
}

// BOOL TYPE
func (b boolVal) Boolean() bool { return bool(b) }
func (b boolVal) Integer() int {
	if b {
		return 1
	} else {
		return 0
	}
}
func (b boolVal) String() string {
	if b {
		return "true"
	} else {
		return "false"
	}
}
func (v boolVal) ToType(t ValueType) Value {
	str := v.String()
	var val Value
	switch t {
	case FLAG:
		//val = flagVal{big.NewRat(1, 1).SetInt64(int64(v.Integer()))}
		val = emptyVal{}
	case INTEGER:
		//val = intVal{big.NewInt(int64(v.Integer()))}
		val = emptyVal{}
	case FLOAT:
		//val = ratVal{big.NewRat(int64(v.Integer()))}
		val = emptyVal{}
	case BYTES:
		//val = bytesVal{v.Integer().Bytes()}
		val = emptyVal{}
	case BYTE:
		//val = byteVal{v.Bytes()[0]}
		val = emptyVal{}
	case STRING:
		val = strVal(v.String())
	default:
		val = emptyVal{}
	}
	return val
}

// FLAG TYPE
func (v flagVal) Flag() flagVal   { return v }
func (v flagVal) BigInt() big.Int { return big.Int(v) }
func (v flagVal) Bytes() []byte   { i := v.BigInt(); return (&i).Bytes() }
func (v flagVal) Uint() uint64    { return v.Uint() }
func (v flagVal) Integer() int64  { return v.Integer() }
func (v flagVal) Boolean() bool {
	if v.Integer() > 0 {
		return true
	} else {
		return false
	}
}
func (v flagVal) String() string {
	val := big.Int(v)
	return string((&val).Bytes())
}
func (v flagVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = flagVal(big.Int(v))
	case INTEGER:
		val = intVal(big.Int(v))
	case FLOAT:
		i := big.Int(v)
		val = ratVal(*big.NewRat(1, 1).SetInt64((&i).Int64()))
	case BYTES:
		i := big.Int(v)
		val = bytesVal((&i).Bytes())
	case BYTE:
		val = byteVal(v.Bytes()[0])
	case STRING:
		val = strVal(string(v.Bytes()))
	default:
		val = emptyVal{}
	}
	return val
}

// INTEGER TYPE
func (v intVal) BigInt() *big.Int     { r := big.Int(v); return &r }
func (v intVal) BigRat() *big.Rat     { return big.NewRat(v.Integer(), 1) }
func (v intVal) BigFloat() *big.Float { return big.NewFloat(v.Float()) }
func (v intVal) Flag() flagVal        { return flagVal(*v.BigInt()) }
func (v intVal) Uint() uint64         { return (v.BigInt()).Uint64() }
func (v intVal) Integer() int64       { return v.BigInt().Int64() }
func (v intVal) Float() float64       { return float64(v.BigInt().Int64()) }
func (v intVal) Bytes() []byte        { return []byte(v.Bytes()) }
func (v intVal) Boolean() bool {
	if v.Integer() > 0 {
		return true
	} else {
		return false
	}
}
func (v intVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = v.Flag()
	case INTEGER:
		val = intVal(*v.BigInt())
	case FLOAT:
		val = ratVal(*v.BigRat())
	case BYTES:
		val = bytesVal(v.Bytes())
	case BYTE:
		val = byteVal(v.Bytes()[0])
	case STRING:
		val = strVal(string(v.Bytes()))
	default:
		val = emptyVal{}
	}
	return val
}

// FLOAT TYPE
func (v ratVal) BigRat() *big.Rat     { r := big.Rat(v); return &r }
func (v ratVal) BigInt() *big.Int     { return big.NewInt(v.Integer()) }
func (v ratVal) BigFloat() *big.Float { return (v).BigFloat() }
func (v ratVal) Float() float64       { f, _ := (v).BigFloat().Float64(); return f }
func (v ratVal) Integer() int64       { return v.BigInt().Int64() }
func (v ratVal) Boolean() bool {
	if v.Float() > 0.0 {
		return true
	} else {
		return false
	}
}
func (v ratVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = ratVal(*v.BigRat())
	case INTEGER:
		val = intVal(*v.BigInt())
	case FLOAT:
		val = ratVal(*v.BigRat())
	case BYTES:
		val = bytesVal(v.BigInt().Bytes())
	case BYTE:
		val = byteVal(v.BigInt().Bytes()[0])
	case STRING:
		val = strVal(string(v.BigInt().Bytes()))
	default:
		val = emptyVal{}
	}
	return val
}

// SINGLE BYTE TYPE
func (v byteVal) Byte() byte  { return byte(v) }
func (v byteVal) Uint() uint8 { return uint8(v) }
func (v byteVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = flagVal(*big.NewInt(int64(v.Uint())))
	case INTEGER:
		val = intVal{big.NewInt(int64(v.Uint()))}
	case FLOAT:
		val = ratVal{big.NewRat(1, 1).SetUint64(v.Uint())}
	case BYTES:
		val = bytesVal([]byte{v.Byte()})
	case BYTE:
		val = byte(v)
	case STRING:
		val = strVal(string(v.Byte()))
	default:
		val = emptyVal{}
	}
	return val
}

// BYTE SLICE TYPE
func (v bytesVal) Bytes() []byte    { return []byte(v) }
func (v bytesVal) String() string   { return string(v) }
func (v bytesVal) Uint() uint64     { return big.NewInt(0).SetBytes(v).Uint64() }
func (v bytesVal) Flag() flagVal    { return flagVal(*big.NewInt(0).SetBytes(v.Bytes())) }
func (v bytesVal) BigInt() *big.Int { return big.NewInt(0).SetBytes(v.Bytes()) }
func (v bytesVal) Uints() (r []uint8) {
	r = []uint8{}
	for _, val := range v {
		b := uint8(val)
		r = append(r, b)
	}
	return r
}
func (v bytesVal) Boolean() bool {
	// see if any bit is set and return
	if len(v) > 1 { // true, when set
		return true
	} else { // false, when no bits are set
		return false
	}
}
func (v bytesVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = &flagVal{big.NewInt(0).SetBytes(v.([]byte))}
	case INTEGER:
		val = &intVal{big.NewInt(0).SetBytes(v.([]byte))}
	case FLOAT:
		val = &floatVal{big.NewRat(1, 1).SetBytes(v.([]byte))}
	case BYTES:
		val = []byte(v)
	case BYTE:
		val = v.Bytes()[0]
	case STRING:
		val = strValue(string([]byte(v)))
	default:
		val = emptyVal{}
	}
	return val
}

// STRING TYPE
func (v strVal) Bytes() []byte  { return []byte(v) }
func (v strVal) String() string { return string(v) }
func (v strVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = &strVal{big.NewInt(0).SetBytes([]byte(v.(string)))}
	case INTEGER:
		val = &strVal{big.NewInt(0).SetBytes([]byte(v.(string)))}
	case FLOAT:
		val = &floatVal{big.NewRat(1, 1).SetBytes([]byte(v.(string)))}
	case BYTES:
		val = []byte(string(v))
	case BYTE:
		val = v.Bytes()[0]
	case STRING:
		val = v
	default:
		val = emptyVal{}
	}
	return val
}

// convenience conversion functions
func (v vecVal) Vector() Value { return v }
func (v vecVal) ToType(t ValueType) Value {
	var val Value
	switch t {
	case FLAG:
		val = emptyVal{}
	case INTEGER:
		val = emptyVal{}
	case FLOAT:
		val = emptyVal{}
	case BYTES:
		var vals = v.Values()
		var bytes = []byte{}
		for _, b := range vals {
			b := []byte(b)
			bytes = append(bytes, b...)
		}
		val = bytesVal(bytes)
	case BYTE:
		val = v.Bytes()[0]
	case STRING:
		val = string(v.Bytes())
	default:
		val = emptyVal{}
	}
	return val
}

// TO-TYPE | FROM-TYPE
//
// if the native tyoe is allready known at the time of initialization,
// reflection can be omitted.
//func toType(i Value, t ValueType) (v Value) {
//	switch t {
//	case NIL:
//		v = emptyVal{}
//	case FLAG:
//		v = &flagVal{big.NewInt(i.(*flagVal).Integer())}
//	case INTEGER:
//		v = &intVal{big.NewInt(i.(*intVal).Int64())}
//	case FLOAT:
//		f, _ := i.(*floatVal).Float64()
//		v = &floatVal{big.NewRat(1, 1).SetFloat64(f)}
//	case BYTES:
//		v = bytesVal(i.(*bytesVal).Bytes())
//	case BYTE:
//		v = i.(byteValue)
//	case STRING:
//		v = strValue(i.(*strValue).String())
//	default:
//		v = emptyVal{}
//	}
//	return v
//}
func fromType(r Value, v Value) {}

// INSTANCIATE A NEW VALUE
//
// instanciate arbitratry values of native type and return instances
// implementing the value interface.
func newValueFromNativeType(i interface{}) Value {
	var v Value
	switch i.(type) {
	case bool:
		if i.(bool) {
			return &flagVal{big.NewInt(1)}
		} else {
			return &flagVal{big.NewInt(0)}
		}
	case uint, uint16, uint32, uint64:
		v = &flagVal{big.NewInt(int64(i.(uint)))}
	case int, int8, int16, int32, int64:
		v = &intVal{big.NewInt(int64(i.(int)))}
	case float32, float64:
		v = &floatVal{big.NewRat(1, 1).SetFloat64(i.(float64))}
	case byte:
		v = byteValue(i.(byte))
	case []byte:
		v = bytesVal(i.([]byte))
	case string:
		v = strValue(i.(string))
	}
	return v
}
